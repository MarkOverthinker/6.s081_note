# mmap

实验目的是将用户空间映射到磁盘文件，使得对该部分用户空间的操作直接映射到磁盘文件上。

#### 大致思路

类似lazy延时分配的方式，在mmap时只记录映射关系，而不用先将文件拷贝到内存当中，当出现page fault时再将文件加载到内存中。

* 在struct proc中创建一个vmaf数组用来记录用户空间到磁盘文件的映射关系，每个vmaf中保存了映射长度、映射起始地址、文件描述符、文件、读写权限、是否写回(MAP\_SHARED,MAP\_PRIVATE)、文件便宜量、vmaf是否映射的信息。
* 题目设定所有传入的起始地址都为0， 真正的起始地址由自己决定，可选择从myproc()->sz处开始映射。mmap时，获取所需的参数。先计算堆上是否还有空余内存可用于计算，之后判断空间读写权限和是否写回以及文件读写方式是否冲突。都没问题后选择一个空闲的vmaf，存入本次mmap的信息，proc->sz增大，增加该文件的被引用次数，mmap完毕。
* 处理页错误，在usertrap中，出现页错误时，查看对应的空间地址是否被mmap映射到文件，对于被映射到文件的用户空间，申请一块内存，将需要的文件内容读取到该内存中，再将用户地址映射到这段内存即可。需要注意读不可读文件和写不可写文件的冲突，在mappages时pte的flag要依据mmap时得到的内存读写执行权限来赋予相应的权限。
* munmap: 根据提示只存在munmap从起始处开始的连续前一段或者以映射空间结束处为munmap结束处，即不能出现从中间阶段munmap一段内存的情况。如果文件可写且这段映射MAP\_SHARED则将文件内容写回，munmap操作很简单，只需更改起始地址和长度即可，若长度为0则说明全部映射已经munmap，则对应的vmaf结束使用，关闭对应的文件，且vmfa->occupied置为0。
* uvmunmap等函数，参照lazy，需要去掉一些对错误pte的判断。
* 修改exit，在进程退出的时候取消所有vmfa的映射并执行关闭文件等操作（同munmap)。
* 修改fork，在创建子线程的时候也要复制vmaf数组，并且将相关文件引用数加一。
