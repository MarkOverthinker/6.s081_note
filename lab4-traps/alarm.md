# Alarm

实现一个系统调用，使进程每隔n个ticks就执行一次指定函数然后返回。

使用到了时间中断。

在调用sigalarm之后，将alarm间隔和alarm的处理函数保存下来(保存在struct proc中，struct proc中还保存了是否正在执行处理函数、已经经过多少ticks、trapframe等信息，创建一个进程时需初始化相关信息)。

在usertrap中，每次通过which\_dev判断导致trap的原因是否为timer interrupt，如果是，则判断是否存在sigalarm的调用，存在则增加已经过的ticks，若已经过的ticks等于alarm间隔，则执行一次alarm处理函数。调用alarm处理函数的方法：先保存当前的trapframe（存储了当前的寄存器也就是运行环境）,之后修改trapframe中的epc,epc表示trap返回后返回到的地址，所以将epc修改为alarm处理函数的地址。在返回后就会执行alarm处理函数。alarm处理函数在执行完操作后调用sigalarmret用于返回到执行alarm前的程序，在sigalarmret中，只需将之前保存程序的trapframe恢复，即可使程序返回到之前的状态，另外要将表示是否存在运行中的alarm处理函数的变量修改为0,表示处理完毕。

踩的一个坑：没有注意处理函数和原来运行中的程序能共享的变量都是全局变量，这类变量都是存储在内存中而非寄存器中，寄存器中存储的都是不共享的。在最初认为可能存在一些变量存在寄存器中，调用处理函数后直接把所有寄存器都复原就导致修改的一些共享的量也复原了，等于没有运行处理函数，实际上由于上述原因这种情况并不存在。
